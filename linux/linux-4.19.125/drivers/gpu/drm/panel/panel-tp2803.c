/**************************************************************************************************
 *
 * Copyright (c) 2019-2024 Axera Semiconductor Co., Ltd. All Rights Reserved.
 *
 * This source file is the property of Axera Semiconductor Co., Ltd. and
 * may not be copied or distributed in any isomorphic form without the prior
 * written consent of Axera Semiconductor Co., Ltd.
 *
 **************************************************************************************************/

#include <linux/module.h>
#include <linux/i2c.h>
#include <linux/regmap.h>
#include <linux/clk.h>
#include <linux/err.h>
#include <linux/version.h>
#include <linux/gpio/consumer.h>
#include <drm/drm_modes.h>
#include <dt-bindings/display/panel-tp2803.h>

#define MODULE_NAME "panel_tp2912_tp2803"

struct reg_cfg {
	u8 addr;
	u8 data;
};

struct tp2803_priv {
	struct regmap *regmap;
	struct gpio_desc *reset_gpio;
	u32 format;
};

static struct reg_cfg reg_bt656_720p25_setting[] = {
	{0x00, 0x00},
	{0x01, 0x00},
	{0x02, 0x8B},
	{0x03, 0x62},
	{0x04, 0x00},
	{0x05, 0x70},
	{0x06, 0x00},
	{0x07, 0xC1},
	{0x08, 0x7A},
	{0x09, 0x7A},
	{0x0A, 0x7A},
	{0x0B, 0x15},
	{0x0C, 0x04},
	{0x0D, 0xF0},
	{0x0E, 0x86},
	{0x0F, 0xBC},
	{0x10, 0x17},
	{0x11, 0xB0},
	{0x12, 0x00},
	{0x13, 0x3C},
	{0x14, 0x38},
	{0x15, 0x39},
	{0x16, 0xEB},
	{0x17, 0x08},
	{0x18, 0x00},
	{0x19, 0xF0},
	{0x1A, 0x10},
	{0x1B, 0xA4},
	{0x1C, 0x72},
	{0x1D, 0x98},
	{0x1E, 0x80},
	{0x1F, 0x00},
	{0x20, 0x27},
	{0x21, 0x88},
	{0x22, 0x04},
	{0x23, 0x23},
	{0x24, 0x86},
	{0x25, 0x40},
	{0x26, 0x00},
	{0x27, 0x56},
	{0x28, 0x00},
	{0x29, 0x34},
	{0x2A, 0x19},
	{0x2B, 0x5e},
	{0x2C, 0x60},
	{0x2D, 0x00},
	{0x2E, 0x40},
	{0x2F, 0x80},
	{0x30, 0x01},
	{0x31, 0x00},
	{0x32, 0x00},
	{0x33, 0x00},
	{0x34, 0x00},
	{0x35, 0x00},
	{0x36, 0x00},
	{0x37, 0x00},
	{0x38, 0x00},
	{0x39, 0x00},
	{0x3A, 0x00},
	{0x3B, 0x90},
	{0x3C, 0x10},
	{0x3D, 0x00},
	{0x3E, 0x18},
	{0x3F, 0x00},
	{0x45, 0x41},
	{0xF0, 0x00},
	{0xF1, 0x68},
	{0xF2, 0x1E},
	{0xF3, 0x4a},
	{0xF4, 0x21},
	{0xF5, 0x00},
	{0xFF, 0x00},
};

static struct reg_cfg reg_bt656_720p30_setting[] = {
	{0x00, 0x00},
	{0x01, 0x00},
	{0x02, 0x8B},
	{0x03, 0x62},
	{0x04, 0x00},
	{0x05, 0x70},
	{0x06, 0x00},
	{0x07, 0xC2},
	{0x08, 0x7A},
	{0x09, 0x7A},
	{0x0A, 0x7A},
	{0x0B, 0x00},
	{0x0C, 0x04},
	{0x0D, 0xF0},
	{0x0E, 0x86},
	{0x0F, 0x72},
	{0x10, 0x06},
	{0x11, 0x64},
	{0x12, 0x00},
	{0x13, 0x3C},
	{0x14, 0x38},
	{0x15, 0x39},
	{0x16, 0xEB},
	{0x17, 0x08},
	{0x18, 0x00},
	{0x19, 0xF0},
	{0x1A, 0x10},
	{0x1B, 0xA4},
	{0x1C, 0x72},
	{0x1D, 0x98},
	{0x1E, 0x80},
	{0x1F, 0x00},
	{0x20, 0x27},
	{0x21, 0x72},
	{0x22, 0x80},
	{0x23, 0x77},
	{0x24, 0x86},
	{0x25, 0x40},
	{0x26, 0x00},
	{0x27, 0x56},
	{0x28, 0x00},
	{0x29, 0x36},
	{0x2A, 0x19},
	{0x2B, 0x5e},
	{0x2C, 0x60},
	{0x2D, 0x00},
	{0x2E, 0x40},
	{0x2F, 0x80},
	{0x30, 0x01},
	{0x31, 0x00},
	{0x32, 0x00},
	{0x33, 0x00},
	{0x34, 0x00},
	{0x35, 0x00},
	{0x36, 0x00},
	{0x37, 0x00},
	{0x38, 0x00},
	{0x39, 0x00},
	{0x3A, 0x00},
	{0x3B, 0xD0},
	{0x3C, 0x10},
	{0x3D, 0x00},
	{0x3E, 0x18},
	{0x3F, 0x00},
	{0x45, 0x40},
	{0xF0, 0x00},
	{0xF1, 0x68},
	{0xF2, 0x1E},
	{0xF3, 0x4a},
	{0xF4, 0x21},
	{0xF5, 0x00},
	{0xFF, 0x00},
};

static struct reg_cfg reg_bt656_cvbs_ntsc[] = {
	{0x02, 0x03},
	{0x03, 0x62},
	{0x05, 0x24},
	{0x07, 0x82},
	{0x08, 0x38},
	{0x09, 0x42},
	{0x0a, 0x28},
	{0x0b, 0x05},
	{0x0c, 0x04},
	{0x0d, 0x04},
	{0x0e, 0x3c},
	{0x0f, 0x5a},
	{0x10, 0x03},
	{0x11, 0x24},
	{0x12, 0x00},
	{0x13, 0x3c},
	{0x15, 0x38},
	{0x1b, 0x97},
	{0x1c, 0x81},
	{0x1d, 0xb6},
	{0x1e, 0x80},
	{0x20, 0x21},
	{0x21, 0xf0},
	{0x22, 0x7c},
	{0x23, 0x1f},
	{0x29, 0x34},
	{0x2a, 0x19},
	{0x3b, 0xd0},
	{0x3c, 0x10},
	{0x3e, 0x18},
	{0x45, 0x40},
	{0xf4, 0xa1},
	{0x3a, 0x00},
	{0xff, 0xff},
};

static struct reg_cfg reg_bt656_cvbs_pal[] = {
	{0x02, 0x1a},
	{0x03, 0x63},
	{0x05, 0x20},
	{0x07, 0xC1},
	{0x08, 0x38},
	{0x09, 0x42},
	{0x0a, 0x28},
	{0x0b, 0x05},
	{0x0c, 0x04},
	{0x0d, 0x04},
	{0x0e, 0x3c},
	{0x0f, 0x60},
	{0x10, 0x03},
	{0x11, 0x20},
	{0x12, 0x04},
	{0x13, 0x3f},
	{0x15, 0x3b},
	{0x1b, 0xa0},
	{0x1c, 0x88},
	{0x1d, 0xc1},
	{0x1e, 0x5f},
	{0x20, 0x48},
	{0x21, 0xbb},
	{0x22, 0x2e},
	{0x23, 0x8b},
	/*
	{0x24, 0x82},
	{0x25, 0x71},
	*/
	{0x29, 0x34},
	{0x2a, 0x19},
	{0x3b, 0xd0},
	{0x3c, 0x10},
	{0x3e, 0x18},
	{0x45, 0x40},
	{0xf4, 0xa1},
	{0x3a, 0x00},
	{0xff, 0xff},
};

static struct reg_cfg reg_bt1120_cvbs_ntsc[] = {
	{0x02, 0x09},
	{0x03, 0x62},
	{0x05, 0x24},
	{0x07, 0x01},
	{0x08, 0x38},
	{0x09, 0x42},
	{0x0a, 0x28},
	{0x0b, 0x05},
	{0x0c, 0x04},
	{0x0d, 0x04},
	{0x0e, 0x3c},
	{0x0f, 0x5a},
	{0x10, 0x03},
	{0x11, 0x16},
	{0x12, 0x04},
	{0x13, 0x3c},
	{0x15, 0x38},
	{0x18, 0x10},
	{0x1b, 0x97},
	{0x1c, 0x81},
	{0x1d, 0xb6},
	{0x1e, 0x80},
	{0x20, 0x48},
	{0x21, 0xbb},
	{0x22, 0x2e},
	{0x23, 0x8b},
	{0x29, 0x34},
	{0x2a, 0x19},
	{0x3b, 0xd0},
	{0x3c, 0x10},
	{0x3e, 0x18},
	{0x45, 0x40},
	{0xf1, 0x08},
	{0xf2, 0x0e},
	{0xf3, 0x4a},
	{0xf4, 0x21},
	{0x3a, 0x00},
	{0xff, 0xff},
};

static struct reg_cfg reg_bt1120_cvbs_pal[] = {
	{0x02, 0x1a},
	{0x03, 0x63},
	{0x05, 0x20},
	{0x07, 0x01},
	{0x08, 0x38},
	{0x09, 0x42},
	{0x0a, 0x28},
	{0x0b, 0x05},
	{0x0c, 0x04},
	{0x0d, 0x04},
	{0x0e, 0x3c},
	{0x0f, 0x60},
	{0x10, 0x03},
	{0x11, 0x20},
	{0x12, 0x04},
	{0x13, 0x3f},
	{0x15, 0x3b},
	{0x1b, 0xa0},
	{0x1c, 0x88},
	{0x1d, 0xc1},
	{0x1e, 0x5f},
	{0x20, 0x48},
	{0x21, 0xbb},
	{0x22, 0x2e},
	{0x23, 0x8b},
	{0x29, 0x34},
	{0x2a, 0x19},
	{0x3b, 0xd0},
	{0x3c, 0x10},
	{0x3e, 0x18},
	{0x45, 0x40},
	{0xf1, 0x08},
	{0xf2, 0x0e},
	{0xf3, 0x4a},
	{0xf4, 0x21},
	{0x3a, 0x00},
	{0xff, 0xff},
};

const struct regmap_config tp2803_regmap_config = {
	.reg_bits = 8,
	.val_bits = 8,
	.max_register = 0xFF,
	.cache_type = REGCACHE_RBTREE,
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5,15,48))
	.use_single_rw = true,
#else
	.use_single_read = true,
	.use_single_write = true,
#endif
};

static int tp2803_read(struct regmap *regmap, u8 reg, u8 *val)
{
	int ret;
	unsigned int regval;

	ret = regmap_read(regmap, reg, &regval);
	if (ret) {
		pr_err("%s read from tp2803@%x failed, ret = %d\n", __func__, reg, ret);
		return ret;
	}

	*val = regval & 0xff;

	return 0;
}

static int tp2803_write(struct regmap *regmap, u8 reg, u8 val)
{
	int ret;

	ret = regmap_write(regmap, reg, val);
	if (ret) {
		pr_err("%s write [0x%x, 0x%x] to tp2803 failed, ret = %d\n", __func__, reg, val, ret);
		return ret;
	}

	return 0;
}

static void tp2803_cfg_write(struct regmap *regmap, struct reg_cfg *cfg)
{
	while (cfg->addr != 0xff) {
		pr_info("%s addr: %x, data: %x\n", __func__, cfg->addr, cfg->data);
		tp2803_write(regmap, cfg->addr, cfg->data);
		cfg++;
	}
}

static struct tp2803_priv *tp2803_priv_p;

static void tp2803_regs_dump( void )
{
	struct regmap *rmap = NULL;
	u8 addr=0x00, val=0;

	pr_emerg("%s start\n", __func__);
	if (IS_ERR_OR_NULL(tp2803_priv_p)) {
		pr_err("tp2803_priv_p is Null\n");
		return;
	}
	rmap = tp2803_priv_p->regmap;

	do {
		tp2803_read(rmap, addr, &val);
		pr_emerg("0x%02X 0x%02X\n", addr, val);
	} while (addr++!=0xFF);
	pr_emerg("%s end\n", __func__);
}

void tp2803_mode_sel(void )
{
	struct regmap *rmap = NULL;

	pr_emerg("%s enter\n", __func__);
	if (IS_ERR_OR_NULL(tp2803_priv_p)) {
		pr_err(MODULE_NAME ": module isn't init.\n");
		return;
	}
	rmap = tp2803_priv_p->regmap;

	if (tp2803_priv_p->reset_gpio) {
		pr_info("%s pull reset pin\n", __func__);
		gpiod_set_value(tp2803_priv_p->reset_gpio, 0);
		gpiod_set_value(tp2803_priv_p->reset_gpio, 1);
	} else {
		return;
	}

	switch (tp2803_priv_p->format) {
	case PANEL_TP2803_BT656_720P_30:
		tp2803_cfg_write(rmap, reg_bt656_720p30_setting);
		break;
	case PANEL_TP2803_BT656_720P_25:
		tp2803_cfg_write(rmap, reg_bt656_720p25_setting);
		break;
	case PANEL_TP2803_BT656_720x480_NTSC:
		tp2803_cfg_write(rmap, reg_bt656_cvbs_ntsc);
		break;
	case PANEL_TP2803_BT656_720x576_PAL:
		tp2803_cfg_write(rmap, reg_bt656_cvbs_pal);
		break;
	case PANEL_TP2803_BT1120_720x480_NTSC:
		tp2803_cfg_write(rmap, reg_bt1120_cvbs_ntsc);
		break;
	case PANEL_TP2803_BT1120_720x576_PAL:
		tp2803_cfg_write(rmap, reg_bt1120_cvbs_pal);
		break;
	default:
		pr_err("%s unsupported mode\n", __func__);
		break;
	}

	tp2803_regs_dump();
	pr_emerg("%s end\n", __func__);
}

static int tp2803_i2c_probe(struct i2c_client *i2c,
			    const struct i2c_device_id *id)
{
	struct tp2803_priv *tp2803;
	int ret;
	u32 format;

	pr_info("%s enter\n", __func__);
	tp2803 = devm_kzalloc(&i2c->dev, sizeof(*tp2803), GFP_KERNEL);
	if (!tp2803)
		return -ENOMEM;

	tp2803->regmap = devm_regmap_init_i2c(i2c, &tp2803_regmap_config);
	if (IS_ERR(tp2803->regmap)) {
		pr_err("%s unable to allocate register map\n", __func__);
		return PTR_ERR(tp2803->regmap);
	}

	dev_set_drvdata(&i2c->dev, tp2803);

	tp2803->reset_gpio = devm_gpiod_get_optional(&i2c->dev, "reset", GPIOD_OUT_LOW);
	if (IS_ERR(tp2803->reset_gpio)) {
		pr_err("%pOF: tp2803 without reset_gpio\n", i2c->dev.of_node);
		return PTR_ERR(tp2803->reset_gpio);
	} else
		gpiod_direction_output(tp2803->reset_gpio, 0);

	ret = of_property_read_u32(i2c->dev.of_node, "panel-format", &format);
	if (ret || format > PANEL_TP2803_BT656_720P_30 || format < PANEL_TP2803_BT656_720x576_PAL) {
		pr_err("tp2803 format invalid\n");
		return EACCES;
	}

	tp2803->format = format;
	tp2803_priv_p = tp2803;

	pr_info("%s done\n", __func__);

	return 0;
}

static int tp2803_i2c_remove(struct i2c_client *client)
{
	tp2803_priv_p = NULL;

	return 0;
}

static int tp2803_detect(struct i2c_client *client, struct i2c_board_info *info)
{
	pr_info("%s enter\n", __func__);
	return 0;
};

static const struct i2c_device_id tp2803_id[] = {
	{"tp2803", 0},
	{}
};

MODULE_DEVICE_TABLE(i2c, tp2803_id);

static const struct of_device_id tp2803_of_match[] = {
	{
		.compatible = "axera,tp2803",
	},
	{}
};

MODULE_DEVICE_TABLE(of, tp2803_of_match);

struct i2c_driver tp2803_i2c_driver = {
	.driver = {
		.name = "tp2803",
		.of_match_table = tp2803_of_match,
	},
	.detect = tp2803_detect,
	.probe = tp2803_i2c_probe,
	.remove = tp2803_i2c_remove,
	.id_table = tp2803_id,
};

module_i2c_driver(tp2803_i2c_driver);

MODULE_DESCRIPTION("Axera tp2803 driver");
MODULE_LICENSE("GPL v2");

